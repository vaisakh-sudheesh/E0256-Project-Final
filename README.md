# E0-256 Project: Building an in-kernel, per-process sandbox


## Problem

The goal of this project is to implement an in-kernel, per-process sandbox. This sandbox will enforce a library-call policy generated from code that the process can execute, and enforced by kernel.

<!-- 
####################################################################################
-->

## Phase-1: Solution Approach

### Phase-1(a): Dummy System Call injection at Libc call-site

LLVM/Clang compiler suite is chosen for deriving library-call policy from a given set of program code.

The solution approach adopted for this project submission can be summarized in the following points:
- Utility program ``LibcListGen`` which accepts a shared library module as input and generates a text file containing an indexed list of functions exposed by the same. 
   - It relies on libelf[5] to process symbol table in the Shared Library (SO File)

- An LLVM Pass is developed to fulfill both the requirements of Dummy-Syscall injection as well as Library Call graph Generation.
   - Due to complexity of LLVM's inbuilt graph and DOT generation feature, the Graaf[19] library is utilized for creation directed graphs, performing operations on them and generating GraphViz/DOT[16] plots.
   - This Pass is developed as an Out-of-Tree standalone module, without requiring to build the complete LLVM source tree.
   - Inorder to do so, the LLVM-development packages version `19.1.5` need to be installed.


<!-- 
####################################################################################
-->

### Phase-1(b): LibC Call graph Generation

The implementation of this module is dependant on the following requirements:
- Identify control flow of a given input code.
- Identify call-site of library calls made from given input code.
- Generate a directed graph out of this information such that the nodes form abstract states of program flow and edges form library calls between abstract states.
- Generate a Graphviz[15][16] formatted output to enable analysis or debugging.

Hence, it is implemented as an analysis pass in LLVM[6][7] Compiler infrastructure using `19.1.5` LLVM/Clang version on Ubuntu.
It consumes the library listing information generated by ``LibcListGen`` to identify candidate functions to monitor.

#### Design Details

- The pass is implemented as an Module/Function Analysis pass.
- The Graph generation pass is divided in to the following phases to keep implementation clean:

   - **Basic Block Naming & Primary graph generation**: Implemented in `LibcSandboxing::nameBasicBlocks` and `LibcSandboxing::runOnModule`.
   ![Basic block named primary graph](/docs/resources/conditional_ifelse.c.lltest_ifelse_1.dot.png)

   - **Function call expansion**: Expanding the available graph by incorporating function calls (Library and internal) one in to the graph. Implemented in `LibcSandboxing::ExpandBBGraph`.
![Expanded graph](/docs/resources/conditional_ifelse.c.lltest_ifelse_1-expanded.dot.png)

   - **Basic Block to Libc Call graph generation**: Implemented in `LibcSandboxing::ConvertBBGraphToLibcCallGraph`, to process the expanded basic block graph in to a library call graph. Here there will be edges for internal function calls too, which will be trimmed in the next step.
   ![Converted to Library call graph](/docs/resources/conditional_ifelse.c.lltest_ifelse_1-libc.dot.png)
   
   
   - **Combining function graphs**: Combining individual function graphs in to a single module level one. Implemented in `LibcSandboxing::CombineLibcgGraph`.
   ![Module level merged graph](/docs/resources/conditional_ifelse.c.llfinal.dot.png)
   
   
   - **In-Memory Graph Generation**: Generates the In-memory graph, which is to be embedded in executable for sand-boxing. Implemented in `LibcSandboxing::GenerateInMemoryGraph`


#### Command Line options for pass

| Command line option   | Purpose     | Description                                                   |
| --------------------- | ----------- | ------------------------------------------------------------- |
| cg-debug              | Debug       | To provide debug information on pass's operation.             |
| cg-output-name        | Output file | Prefix file name for the output file from the pass.           |
| cg-output-path        | Output path | Path prefix to store output from the pass.                    |
| cg-lib-funcs-path     | Input       | Library call mapping file generated by ``LibcListGen``.       |


<!-- 
####################################################################################
-->

## Phase-2: Solution Approach

The implementation of this phase/module is dependant on the following requirements:
- The library call graph information generated by Phase-1 module need to be consumed by Phase-2 implementations.
- The dummy system calls injected in to the code in phase-1 need to be monitored to ensure whether indeed the program being sanboxed is following its expected path of execution.
- If it is not following the expected library-call-flow path as shared by the graph, the program need to be terminated by kernel.
- The implementation need to be mostly kernel centered and any userspace framework like ptrace need to be avoided.

### Design details

Inorder to meet the stated requirements, following design consideration are made:
- The sandbox operation will be performed completely in the kernel, with the validity of program's abstract state between system calls (indicating library calls) are monitored and graph is enforced.
- The key points while designing to keep the following graph operations as light weight as possible :
  - loading of graph
  - transition between states
  - validity of states
  - sanity of graph data

The following subsections provide details about the design implementation to achieve above mentioned points/requirements.

#### Executable code information exchange between userspace and kernel

Traditionally, a linker is provided input from compiler, as well as a Linker Definition File [18] wherein information and placement about sections in the executable code is provided. This information will be made use by Operating System(specifically loader), to place content in the processes memory context(Process Memory Map). Several configurations can be enforced in each section to ensure appropriate permissions are applied for these section.

Below code shows a placement of a buffer containing some arbitrary string in to a section named ``sandbox_init_data_section``

```C
const char sandbox_data[] __attribute__((section("sandbox_init_data_section"))) = "This is some data in sandbox_init_data, to test if it works";
const long sandbox_init_data_size = sizeof(sandbox_data);
```

When the code is compiled in to an executable file, this section too gets included and will be accessible for kernel as well. And this is ensured by an additional system call ``sandbox_init`` which will be issued on invoking ``main`` function from the program. 

The graph information, will be copied in to this (``sandbox_init_data_section``)section and read by kernel on ``sandbox_init`` system call - so the graph data will be copied once, during the program start.

#### Graph Representation

Inorder to have a common implementation between user-space and kernel to ensure uniformity of graph data handling, a ``memgraphlib`` library with the below listed APIs is developed.
```C
/* Library APIs */

void initialize_graph(void *data, unsigned long size);
void destroy_graph(void);
void *get_graph(void);

#ifndef __KERNEL__
void store_graph(const char *filename);
void load_graph(const char *filename);
void *alloc_node(unsigned long id, int num_successors, unsigned long *successor_node_list, unsigned long *libcall_list);
void finalize_graph(void);
#endif // __KERNEL__
int verify_graph(void);

void reset_progstate(void);
int is_state_transition_valid (unsigned long libccall);
int transition_to_state(unsigned long libccall);

#ifdef __cplusplus
```

When library is compiled and used in a user-space module, it will be provided by Graph creation, verification and viewing functionality. If the the same module is compiled for kernel-space, only graph verification and viewing functionality will be provided to the kernel.

Below code listing shows the layout of the memory-pool which stores the graph information in a ``struct graph_metadata``. 

```C
#define GRAPH_META_MAGIC_NUMBER     (0xDEADBEEF)        // Magic number for graph metadata

/**
 * Structure to represent the metadata of the graph.
 * @note This will be stored at the beginning of the memory pool.
 * 
 * @details The memory pool will be used to store the graph and will be created only once.
 *          The graph will be stored in the memory pool in a serialized format
 * 
 *          Layout of this memory pool:
 *              +-------------------------+
 *              |  Graph Metadata         |  <!-- This structure -->
 *              |                         |  <!-- Containing metadata and offsets to the other sections -->
 *              +-------------------------+
 *              |  Node Table             | <!-- This will be used to store the nodes and edges -->
*               |                         | 
 *              +-------------------------+
 *              |  Node Listings          | <!-- This will be used as a quick lookup table for nodes -->
 *              |                         | <!-- Will be populated after graph is finalized -->
 *              +-------------------------+
 * 
 * 
 */
struct graph_metadata {
    unsigned long   magic;                // Magic number to ensure sanity of data
    unsigned long   version;              // Version of the graph
    unsigned long   checksum;             // Checksum of the graph
    unsigned long   total_size;           // Total size of the memory pool

    unsigned char   graph_finalized;      // Flag to indicate if the graph is finalized

    unsigned char   reserved0[15];        // Reserved for future use
    unsigned char   reserved1[16];        // Reserved for future use
    


    /* Abstract Program State (Nodes) information */
    unsigned long   num_nodes;            // Number of nodes in the graph

    unsigned long   nodes_table_offset;   // Offset to the nodes table
    unsigned long   nodes_table_size;     // Size of the nodes table
};

/**
 * Structure to represent the memory pool.
 * @note This will be embedded in the program's memory space.
 * @note This will be used to store the graph.
 */
struct memory_pool {
    struct graph_metadata       metadata;
    /** Node Table to represent graph/automaton **/
};
```
- The Memory pool has a small header section, wherein information about the graph such as number of nodes, checksum and total size of the region is included.
- A magic number field is included in the header which helps to ensure, if indeed we are reading the right data structure in memory. Its expected value is ``0xDEADBEEF``.
- The check sum functionality is not implemented due to the lack of time, but it can be plugged in easily.


Furthermore, following the header information, the rest of memory pool will include nodes and edges information represented as ``struct abstract_progstate`` and ``struct libcalls`` respectively, as listed below. Each of these structures too include a magic number included in them, with its values as ``0xCAFEBABE`` for the nodes and ``0xBAADF00D`` for the edges.

```C
/* Magic numbers to ensure sanity of data being processed */
#define NODE_MAGIC_NUMBER       (0xCAFEBABE)
#define EDGE_MAGIC_NUMBER       (0xBAADF00D)

/**
 * Structure to represent a library call (edges in the graph).
 */
struct libcalls {
    unsigned long magic;
    unsigned long libcallid;
    unsigned long next_progstate;
};

/**
 * Structure to represent a program state (Nodes in the graph).
 */
struct abstract_progstate{
    unsigned long magic;
    unsigned long id;
    unsigned long num_libcalls;
};

```

The magic number included in the header, nodes and edges together help in providing a limited form of sanity assurance for the graph data.

#### Sandbox Implementation Approach

- As mentioned earlier, the graph information is loaded in to the kernel at the begining of ``main`` function call.
- The state (starting node) of the graph is reset to the root node during this initiation.
- On the receipt of each dummy system call, the state transition is validated as a simple lookup and edge/next-node check against the current node-pointer.
```diff
+335 64      sandbox_dummycall   sys_sandbox_dummycall
+336 64      sandbox_init   sys_sandbox_init
+337 64      sandbox_cleanup   sys_sandbox_cleanup
```

- If the next-state transition is not a valid one, kernel code issues a ``do_exit(SIGKILL)``  call within the ``sandbox_dummycall`` system call flow.
- While on the other hand, the system call returns without any failure, if the transition is accepted.

<!-- 
####################################################################################
-->

## Design Discussion

The key pros/cons of the mentioned approach are listed below:
- The major overhead in terms of CPU time and memory will only be present during the ``sandbox_init`` operation as there is buffer allocation and copying involved.
- The rest of the ``sandbox_dummycall`` calls will incur only negligible overhead as it is more or less memory lookup; this can help in an near-optimal runtime performance
- Though not implemented and evaluated against an eBPF based method, this approach is intuitively better in terms of runtime performance.
- The sanity and safety of the approach is based on the assurance that the graph data embedded within the program memory should be tampered with:
   - Magic numbers to ensure in-memory and storage-time sanity
   - A checksum field validation to ensure whether indeed tampering is done or not; which is not implemented due to lack of time - but provisions are added.
   - A stronger method may be using signatures to sign the generated graph; which is not implemented due to lack of time.
- There may be other thread models possible, wherein an attacker can modify the embedded graph information, which is not addressed in this implementation.

<!-- 
####################################################################################
-->



## Source Layout

```bash

.
├── busybox                                             ## Patches and modules for busybox integration
│   ├── miscutils                                       #### Simple testing utility
│   │   ├── syscalltest.c
│   │   └── syscalltest-support.c
│   ├── 0001-E0256-Necessary-integrations.patch         #### Patch to be applied to busybox for desired build configuration
│   ├── init-noshell.ref                                #### Reference init-script for ramdisk - which boots and runs a set of commands powersoff
│   ├── init.ref                                        #### Reference init-script for ramdisk - which boots into shell
│   ├── package_initramfs.sh                            #### Utility script invoked by `initrd.cmake` to package ramdisk
│   └── shinit.ref                                      #### Reference shell setting (alias)
|
├── cmake                                              ## CMakerules to build individual modules
│   ├── busybox.cmake                                  ### Busybox Fetch, patch, integrated and build rules
│   ├── initrd.cmake                                   ### Packaging initrd
│   ├── kernel.cmake                                   ### Linux Kernel Fetch, patch, integrated and build rules
│   └── utils.cmake                                    ### Utility scripts
│
├── GraphLib                                           ## Utility library for creating graph and GraphViz DOT files - used by LLVM Pass
│   ├── includes
│   │   └── GraphLib.hpp
│   ├── CMakeLists.txt
│   └── GraphLib.cpp
│
├── kernel                                              ## Patches and modules for kernel integration
│   ├── e0256-sandboxing                                #### Module which will be integrated in to `kernel/security/` for sandboxing
│   │   ├── memgraphlib                                 #### Utility library to represent graph in memory 
│   │   │   ├── export
│   │   │   │   └── memgraph.h
│   │   │   ├── tests                                   
│   │   │   │   ├── test_data
│   │   │   │   │   ├── test-case-1.txt
│   │   │   │   │   ├── test-case-2.txt
│   │   │   │   │   └── test-case-3.txt
│   │   │   │   ├── test_memgraph.cc 
│   │   │   │   └── test_utils.h
│   │   │   ├── CMakeLists.txt                         #### CMake rule for user-space library build
│   │   │   ├── definitions.h
│   │   │   ├── Makefile                               #### Makefile to be used for in-kernel build
│   │   │   ├── memgraph.c
│   │   │   ├── requirements.txt
│   │   │   └── utils.h
|   |   |
│   │   ├── Makefile
│   │   └── sandboxing.c                               #### System Call implementation 
|   |
│   ├── 0001-Necessary-changes-to-include-module.patch #### Patch for necessary change and module integration 
│   ├── kernel_x86-qemu-minimal_defconfig              #### Minimalistic defconfig for qemu build and boot up
│   ├── syscall-tbl_6.11.9.patch                       #### Syscall table patch for 6.11.9 kernel
│   └── syscall-tbl_ 6.8.11.patch                      #### Syscall table patch for 6.8.11 kernel build
│
├── LibcListGen                                        ## Utility tool to generate listing of library function names and unique ID for each
│   ├── CMakeLists.txt
│   └── LibcFuncDump.cpp
│
├── LLVM                                               ## LLVM Pass for Dummy-syscall integration, LibraryCall graph generation
│   ├── CMakeLists.txt
│   ├── LibcCallGraphDebug.h
│   ├── LibcCallGraphGen.cpp
│   └── LibcCallGraphUtils.h
│
├── test                                               ## Test code and test-build rules
│   ├── testcodes                                      #### The test codes within this directory will automatically compiled, and sandboxed.
│   │   ├── conditional_ifelse.c
│   │   ├── conditional_switchcase.c
│   │   ├── helloworld.c
│   │   ├── loop_dowhile.c
│   │   ├── loop_for.c
│   │   ├── loop_while.c
│   │   └── mixed_code.c
│   ├── CMakeLists.txt
│   ├── helloworld.c
│   ├── libc_listing.lst
│   └── syscall-test.c
│
├── CMakeLists.txt
└── README.md



## Build Instructions

<!-- 
####################################################################################
-->

## Pre-requisites/Dependencies

The following packages need to be installed for rest of the build including LLVM Pass and solution modules.
```sh
$ sudo apt install -Y gcc g++ cmake ninja-build  bzip2 graphviz libelf-dev ltrace libncurses-dev gawk flex bison openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf qemu-system-x86 
$ wget https://apt.llvm.org/llvm.sh
$ chmod +x llvm.sh
$ sudo ./llvm.sh 19

```

<!-- 
####################################################################################
-->

## Component Versions 

| Component    | Version        | Purpose                                                                           |
| ------------ | -------------- | --------------------------------------------------------------------------------- |
| Linux Kernel | 6.8.11 [11]    | Implement sandbox module to observe and manage sand-boxed process execution.      |
| BusyBox [12] | 1.37.0 [13]    | To generate minimal utilities packed initrd[17] image for kernel to boot into.    |



<!-- 
####################################################################################
-->

## Building with cmake

The build system has been setup to download all the necessary source code, patch and integrate modules in them and build the binaries.

```shell
$ mkdir build-dir && cd build-dir

## Setting up the source tree using download rules
$ cmake -S ..

## Start build of all modules 
$ cmake --build . 

```

After this build, the artifacts will be available in `<Project-root-dir>/out-dir`

```shell
.
├── asm                                       ## Intermediate output during compilation and final linking.
│   ├── conditional_ifelse.c.s
│   ├── conditional_switchcase.c.s
│   ├── helloworld.c.s
│   ├── loop_dowhile.c.s
│   ├── loop_for.c.s
│   ├── loop_while.c.s
│   └── mixed_code.c.s
│
├── dot                                        ## Raw/PNG Graph output of the test files 
│   ├── conditional_ifelse.c.llfinal.dot
│   ├── conditional_switchcase.c.llfinal.dot
│   ├── helloworld.c.llfinal.dot
│   ├── loop_dowhile.c.llfinal.dot
│   ├── loop_for.c.llfinal.dot
│   ├── loop_while.c.llfinal.dot
│   └── mixed_code.c.llfinal.dot
│
├── graph                                      ## DOT/PNG Graph output of the test files 
│   ├── conditional_ifelse.c.llfinal.dot.png
│   ├── conditional_switchcase.c.llfinal.dot.png
│   ├── helloworld.c.llfinal.dot.png
│   ├── loop_dowhile.c.llfinal.dot.png
│   ├── loop_for.c.llfinal.dot.png
│   ├── loop_while.c.llfinal.dot.png
│   └── mixed_code.c.llfinal.dot.png
│
├── ir                                         ## LLVM/IR Intermediate output files 
│   ├── conditional_ifelse.c.ll
│   ├── conditional_switchcase.c.ll
│   ├── helloworld.c.ll
│   ├── loop_dowhile.c.ll
│   ├── loop_for.c.ll
│   ├── loop_while.c.ll
│   └── mixed_code.c.ll
│
├── opt-out                                    ## LLVM Opt output for standalone evaluation
│   ├── conditional_ifelse.c.out
│   ├── conditional_switchcase.c.out
│   ├── helloworld.c.out
│   ├── loop_dowhile.c.out
│   ├── loop_for.c.out
│   ├── loop_while.c.out
│   └── mixed_code.c.out
│
├── out                                        ## Executable files - will be packaged in to Ramdisk during build
│   ├── conditional_ifelse.c.out
│   ├── conditional_switchcase.c.out
│   ├── helloworld.c.out
│   ├── loop_dowhile.c.out
│   ├── loop_for.c.out
│   ├── loop_while.c.out
│   └── mixed_code.c.out
│
├── bzImage                                    ## Bootable kernel image for Qemu
└── initramfs-busybox-x86.cpio.gz              ## Ramdisk/Initrd to boot into


```

<!-- 
####################################################################################
-->

## Running Kernel Image

```bash
$ cd build-dir   # Same directory as the project was built

$ qemu-system-x86_64 -kernel ../out-dir/bzImage -initrd ../out-dir/initramfs-busybox-x86.cpio.gz -nographic -append "console=ttyS0"
```
<!-- 
####################################################################################
-->
## End-to-end Evaluation

```bash
~ # conditional_ifelse.c.out 
[  156.678275] Sandbox Init Syscal with buffer size 1048576
[  156.678934] Successfully copied data from user space
[  156.678983] Data[0]: 239
[  156.679105] Data[1]: 190
[  156.679127] Data[2]: 173
[  156.679151] Data[3]: 222
[  156.679187] Data[4]: 0
[  156.679219] Data[5]: 0
[  156.679242] Data[6]: 0
[  156.679269] Data[7]: 0
[  156.679293] Data[8]: 1
[  156.679323] Data[9]: 0
[  156.679351] Data[10]: 0
[  156.679381] Data[11]: 0
[  156.679408] Data[12]: 0
[  156.679437] Data[13]: 0
[  156.679466] Data[14]: 0
[  156.679496] Data[15]: 0
[  156.679526] Data[16]: 0
[  156.679559] Data[17]: 0
[  156.679588] Data[18]: 0
[  156.679622] Data[19]: 0
[  156.679652] Initializing in-memory graph
[  156.680359] Graph initialized from buffer and verified.
[  156.680359] 
[  156.680501] Sandbox Dummy Syscall: 2611
[  156.680577] Sandbox Dummy Syscall: invalid transition
Killed

```

<!-- 
####################################################################################
-->
## References

[1] **LibTooling**. Clang 18.1.8 documentation. https://releases.llvm.org/18.1.8/tools/clang/docs/LibTooling.html (Viewed on 12 October 2024)

[2] **Introduction to the Clang AST**. Clang 18.1.8 documentation. https://releases.llvm.org/18.1.8/tools/clang/docs/IntroductionToTheClangAST.html (Viewed on 12 October 2024)

[3] **How to write RecursiveASTVisitor based ASTFrontendActions**. Clang 18.1.8 documentation.  https://releases.llvm.org/18.1.8/tools/clang/docs/RAVFrontendAction.html (Viewed on 12 October 2024)

[4] Wikipedia contributors. (2024, September 9). **Source-to-source compiler**. In Wikipedia, The Free Encyclopedia. Retrieved 15:05, October 13, 2024, from https://en.wikipedia.org/w/index.php?title=Source-to-source_compiler&oldid=1244784493

[5] **LibELF** - package information. Ubuntu Launchpad. https://launchpad.net/ubuntu/jammy/+package/libelf-dev  (Viewed on 12 October 2024)

[6] LLVM Compiler Infrastructure Documentation. **Writing an LLVM Pass**. https://llvm.org/docs/WritingAnLLVMNewPMPass.html (Viewed on 12 October 2024)

[7] LLVM Compiler Infrastructure Documentation. **Writing an LLVM Pass (Legacy Version)**. https://llvm.org/docs/WritingAnLLVMPass.html (Viewed on 12 October 2024)

[8] **Clang Tutorial Part II: LibTooling Example**.  July 23, 2013.  https://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-ii-libtooling-example/ (Viewed on 12 October 2024)

[9] Eli Bendersky's website. **Modern source-to-source transformation with Clang and libTooling**. May 01, 2014.  https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling (Viewed on 12 October 2024)

[10] Wikipedia contributors. (2024, May 21). **Ltrace**. In Wikipedia, The Free Encyclopedia. Retrieved 15:55, October 13, 2024, from https://en.wikipedia.org/w/index.php?title=Ltrace&oldid=1224937011

[11] **Linux Kernel 6.8.11** - Release tarball archive, https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.8.11.tar.xz   (Viewed on 20 November 2024)

[12] Busybox Portal, https://busybox.net/  (Visited 20-November-2024)

[13] **Busybox 1.37.0** - Release tarball, https://busybox.net/downloads/busybox-1.37.0.tar.bz2 (Visited 20-November-2024)

[14] **LLVM Project 18.1.8** - Release tarball, https://github.com/llvm/llvm-project/releases/download/llvmorg-18.1.8/llvm-project-18.1.8.src.tar.xz  (Visited 20-November-2024)

[15] Emden R. Gansner and Stephen C. North. 2000. **An open graph visualization system and its applications to software engineering**. Softw. Pract. Exper. 30, 11 (Sept. 2000), 1203–1233.

[16] **Graphviz** official portal, https://graphviz.org/ (Visited 20-November-2024)

[17] Linux Kernel documentation - **Using the initial RAM disk (initrd)**, https://docs.kernel.org/admin-guide/initrd.html (Visited 20-November-2024)

[18] Miguel Young de la Sota., mcyoung blog, **Everything You Never Wanted To Know About Linker Script**, https://mcyoung.xyz/2021/06/01/linker-script/ (Visited 20-November-2024)

[19] graaf: A general-purpose lightweight C++ graph library , https://github.com/bobluppes/graaf  (Visited 20-November-2024)