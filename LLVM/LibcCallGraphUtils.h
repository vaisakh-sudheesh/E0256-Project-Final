#ifndef LLVM_ANALYSIS_UTILS_LIBCCALLGRAPHUTILS_H
#define LLVM_ANALYSIS_UTILS_LIBCCALLGRAPHUTILS_H


#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Instructions.h"

#include <fstream>
#include <vector>
#include <map>
#include <string>

namespace llvm {

    /**
     * @brief Class to read a file containing key-value pairs and store them in a map
     *
     * @details The file should contain one key-value pair per line, with the key and value separated by a colon.
     */
    class FileToMapReader {
        private:
        std::map<std::string, int> stringMap;
        bool loaded = false;

        public:
        /**
         * @brief Check if the file has been loaded
         * 
         * @return true if the file has been loaded, false otherwise
         */
        bool isLoaded() const {
            return loaded;
        }

        /**
         * @brief Read the file containing key-value pairs and store them in a map
         * 
         * @param filePath The path to the file to read
         * @return true if the file was read successfully, false otherwise
         * 
         * @details The file should contain one key-value pair per line, with the key and value separated by a colon.
         * The key should be a string and the value should be an integer.
         * 
         * @details This input file will be generated by the library_func_dump utility.
         */
        bool readFileToMap(const std::string &filePath) {
            std::ifstream file(filePath);
            loaded = false;
            if (!file.is_open()) {
                llvm::errs() << "Error opening file: " << filePath << "\n";
                return false;
            }

            std::string line;
            while (std::getline(file, line)) {
                size_t colonPos = line.find(':');
                if (colonPos != std::string::npos) {
                    std::string key = line.substr(colonPos + 1);
                    int value = std::stoi(line.substr(0, colonPos));
                    stringMap[key] = value;
                } else {
                    llvm::errs() << "Invalid line format: " << line << "\n";
                }
            }
            file.close();
            loaded = true;
            return true;
        }

        /**
         * @brief Check if a string is in the map
         * 
         * @param str The string of function name to look up
         * @return true if the string is in the map, false otherwise
         */
        bool isStringInMap(const std::string &str) const {
            if (!loaded) {
                return false;
            }
            return stringMap.find(str) != stringMap.end();
        }

        /**
         * @brief Get the value associated with a string in the map
         * 
         * @param str The string of function name to look up
         * @return The value associated with the string, or -1 if the string is not in the map
         */
        int getValueFromMap(const std::string &str) const {
            auto it = stringMap.find(str);
            if (it != stringMap.end()) {
            return it->second;
            }
            return -1; // or some other sentinel value indicating not found
        }

        std::vector<std::string> getLibraryCalls (BasicBlock &BB) {
            std::vector<std::string> libCalls;
            for (Instruction &I : BB) {
                if (CallInst *CI = dyn_cast<CallInst>(&I)) {
                    Function *Callee = CI->getCalledFunction();
                    if (Callee) {
                        std::string funcName = Callee->getName().str();
                        if (isStringInMap(funcName)) {
                            libCalls.push_back("libc:"+funcName);
                        } else if (Callee->isIntrinsic()) {
                            libCalls.push_back("llvm:"+funcName);
                        } else if (Callee->isDeclaration()) {
                            libCalls.push_back("decl:"+funcName);
                        } else {
                            libCalls.push_back("user:"+funcName);
                        }
                    }
                }
            }
            return libCalls;
        }

      
    };


}
#endif // LLVM_ANALYSIS_UTILS_LIBCCALLGRAPHUTILS_H

