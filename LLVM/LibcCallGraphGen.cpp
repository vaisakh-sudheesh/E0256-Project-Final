#include "llvm/IR/Module.h"
#include "llvm/IR/PassManager.h"
#include "llvm/Pass.h"

#include "LibcCallGraphUtils.h"

#include <map>
#include <string>
#include <vector>

//------------------------------------------------------------------------------
// New PM interface
//------------------------------------------------------------------------------
struct LibcSandboxing : public llvm::PassInfoMixin<LibcSandboxing> {
private:
    llvm::FileToMapReader fileToMapReader;

    llvm::Function *DummySyscallF;
    llvm::FunctionCallee DummySyscall;

public:
    llvm::PreservedAnalyses run(llvm::Module &M,
                                llvm::ModuleAnalysisManager &);
    bool runOnModule(llvm::Module &M, llvm::ModuleAnalysisManager &MAM, llvm::FunctionAnalysisManager &FAM);

    static bool isRequired() { return true; }

    void setupDummySyscall(llvm::Module &M);
    void injectDummySyscall(llvm::Instruction &I, int syscallNum);

    void GenerateInMemoryGraph(llvm::Module &M);

    void nameBasicBlocks(llvm::Function &F);
    void SectionAddressHandler(llvm::Module &M, unsigned char *data, unsigned long size);
    void MemoryCleanupHandler(llvm::Module &M);
};

#include "llvm/IR/IRBuilder.h"
#include "llvm/Passes/PassPlugin.h"
#include "llvm/Passes/PassBuilder.h"

using namespace llvm;

#define DEBUG_TYPE "libc-sandboxing"

#include "GraphLib.hpp"

//------------------------------------------------------------------------------
// Command line options
//------------------------------------------------------------------------------
/**
 * @brief Command line option to enable debug mode
 *
 * @details This option allows the user to enable debug mode for the libc call graph pass.
 */
static cl::opt<bool>
libcCallGraphDebug("cg-debug",
                  cl::desc("Enable debug mode for libc call graph pass."),
                  cl::Hidden,
                  cl::init(false));

#include "LibcCallGraphDebug.h"


/**
 * @brief Command line option to specify the output filename prefix
 *
 * @details This option allows the user to specify a prefix for the output filename.
 */
static cl::opt<std::string> OuputFilenamePrefix(
    "cg-output-name",
    cl::desc("Prefix name for the output file."),
    cl::value_desc("filename"),
    cl::init(""));

/**
 * @brief Command line option to specify the output filepath prefix
 *
 * @details This option allows the user to specify a prefix for the output filepath.
 */
static cl::opt<std::string> OuputFilepathPrefix(
    "cg-output-path",
    cl::desc("Prefix path for the output file."),
    cl::value_desc("filepath"),
    cl::init(""));

/**
 * @brief Command line option to specify the input file containing the libc functions listing
 *
 * @details This option allows the user to specify the input file containing the libc functions listing.
 */
static cl::opt<std::string> InputLibFuncsPath(
    "cg-lib-funcs-path",
    cl::desc("Input file for the libc functions listing generated by library_func_dump utility"),
    cl::value_desc("filepath"),
    cl::init(""));


/**
 * @brief Command line option to print the control flow graph in DOT format, i.e. the first pass
 *
 * @details This option allows the user to print the control flow graph in DOT format, i.e. the first pass - for debugging purposes
 */
static cl::opt<bool> PrintControlflowGraph(
    "cg-print-cfg",
    cl::desc("Print the control flow graph in DOT format"),
    cl::Hidden,
    cl::init(false));


/**
 * @brief Command line option to print the libc call graph in DOT format, i.e. the second pass
 *
 * @details This option allows the user to print the libc call graph in DOT format, i.e. the second pass - for debugging purposes
 */
static cl::opt<bool> PrintLibcCallGraph(
    "cg-print-libc-cg",
    cl::desc("Print the libc call graph in DOT format"),
    cl::Hidden,
    cl::init(false));
    
//-----------------------------------------------------------------------------
// Adding a new section to the binary - to store the sandbox init data
//-----------------------------------------------------------------------------

void LibcSandboxing::SectionAddressHandler(Module &M, unsigned char *data, unsigned long size) {
 LLVMContext &CTX = M.getContext();
        IRBuilder<> Builder(CTX);

        // Define the section name you want to add
        const char *sectionName = "sandbox_init_data_section";

        // Create a new global variable in the specified section
        ArrayType *arrayType = ArrayType::get(Type::getInt8Ty(CTX), size);
        GlobalVariable *newGlobal = new GlobalVariable(
            M, arrayType, false, GlobalValue::ExternalLinkage,
            Constant::getNullValue(arrayType), "SanboxInitData");

        newGlobal->setSection(sectionName);

        // Optionally, initialize the global variable with some data
        std::vector<Constant *> initValues;
        for (int i = 0; i < size; ++i) {
            initValues.push_back(ConstantInt::get(Type::getInt8Ty(CTX), data[i]));
        }
        Constant *initArray = ConstantArray::get(arrayType, initValues);
        newGlobal->setInitializer(initArray);

        for (auto &F : M) {
            if (F.isDeclaration())
                continue;
            std::string funcName = F.getName().str();
            if (funcName.find("main") == 0){
                PointerType *PrintfArgTy = PointerType::getUnqual(Type::getInt8Ty(CTX));

                IRBuilder<> Builder(&*F.getEntryBlock().getFirstInsertionPt());

                llvm::Value *syscallNumber = Builder.getInt64(337);
                auto bufferPtr = Builder.CreatePointerCast(newGlobal, PrintfArgTy, "bufferPtr");
                Builder.CreateCall(
                    DummySyscall, {syscallNumber, bufferPtr, Builder.getInt64(size)});
            }
        }

}

void LibcSandboxing::MemoryCleanupHandler(Module &M) {
 LLVMContext &CTX = M.getContext();
        IRBuilder<> Builder(CTX);

        for (auto &F : M) {
            if (F.isDeclaration())
                continue;
            std::string funcName = F.getName().str();
            if (funcName.find("main") == 0){

                Instruction *lastInst = nullptr;
                for (auto &BB : F) {
                    for (auto &I : BB) {
                        if (isa<ReturnInst>(I)) {
                            break;
                        }
                        lastInst = &I;
                    }
                }
                IRBuilder<> Builder(lastInst);

                llvm::Value *syscallNumber = Builder.getInt64(338);
                Builder.CreateCall( DummySyscall, {syscallNumber});
            }
        }

}


//------------------------------------------------------------------------------
// Dummy syscall setup & injection
//------------------------------------------------------------------------------
void LibcSandboxing::setupDummySyscall(Module &M) {
    // Create a function that will be called by the injected call
    auto &CTX = M.getContext();
    IntegerType *Int64Ty = Type::getInt64Ty(CTX);

    FunctionType *SyscallTy = FunctionType::get(
        Type::getInt64Ty(CTX),
        Int64Ty,
        /*isVarArg=*/true);

    
    DummySyscall = M.getOrInsertFunction("syscall", SyscallTy);
    assert(DummySyscall && "Syscall function not found");

    // Set attributes as per inferLibFuncAttributes in BuildLibCalls.cpp
    DummySyscallF = dyn_cast<Function>(DummySyscall.getCallee());
    DummySyscallF->setDoesNotThrow();
}

void LibcSandboxing::injectDummySyscall(Instruction &I, int syscallNum){
    
    IRBuilder<> Builder(&I);

    llvm::Value *syscallNumber = Builder.getInt64(336);
    Builder.CreateCall(
        DummySyscall, {syscallNumber, Builder.getInt64(syscallNum)});
    
}



//------------------------------------------------------------------------------
// Utility functions for Basic block operations
//------------------------------------------------------------------------------

void LibcSandboxing::nameBasicBlocks(llvm::Function &F){
    std::string bbStr;
    raw_string_ostream bbStream(bbStr);
    std::string funcName = F.getName().str();

    for (BasicBlock &BB : F) {
        BB.printAsOperand(bbStream, false);
        BB.setName("["+funcName+"]"+bbStream.str()); // setting the name of the basic block to its label
        bbStr.clear();
    }    
}

//-----------------------------------------------------------------------------
// Data structures to store the basic block graphs
//-----------------------------------------------------------------------------

struct funcBBGraphMeta {
    std::string funcName;

    // Entry and exit node names
    std::string entryNode;
    std::string exitNode;

    // Map to store the libc calls for each basic block
    std::map <std::string, std::vector<std::string>> bbToLibcMap;

    LibcCallgraph bbGraph;          // Just basic block control flow graph
    LibcCallgraph bbExpandedGraph;  // Graph with libc calls expanded
    LibcCallgraph libcCallGraph;    // Graph with libc calls and program abstract state 
};
std::map<std::string, funcBBGraphMeta> funcBBToMetaMap;

std::string finalGraphEntryNode;
std::string finalGraphExitNode;
LibcCallgraph finalGraph;           // Final graph with libc calls and program abstract state

//------------------------------------------------------------------------------
// Expand the basic block graph to include function calls
//------------------------------------------------------------------------------

/**
 * @brief Expand the basic block graph to include function calls
 */
void ExpandBBGraph(){
    for (auto &entry : funcBBToMetaMap) {
        auto &funcMeta = entry.second;
        const auto &funcName = entry.first;
        const auto &bbGraph = funcMeta.bbGraph;
        auto &bbExpandedGraph = funcMeta.bbExpandedGraph;
        // DEBUG_PRINT(BOLD_RED << "===================================================== " RESET << "\n");
        // DEBUG_PRINT(BOLD_GREEN << "Function: " << BOLD_WHITE << funcName << RESET << "\n");
        // DEBUG_PRINT(BOLD_RED << "===================================================== " RESET << "\n");
        bbExpandedGraph = bbGraph;

        // Expand the edges
        int counter=1;
        bool hadLibcCalls = false;
        std::string tempBBName, prevVertex, finalVertex, firstVertex;
        std::vector<std::string> neighbors;
        for (const auto &bbEntry : funcMeta.bbToLibcMap) {
            const auto &bbName = bbEntry.first;
            
            // DEBUG_PRINT(BOLD_YELLOW << "Checking neighbors for : "<< BOLD_WHITE << bbEntry.first<< RESET << "\n");
            firstVertex = bbEntry.first;
            neighbors = bbExpandedGraph.get_neighbors(bbEntry.first);
            // for (const auto &vertex : neighbors) {
            //      DEBUG_PRINT(BOLD_YELLOW << "\tVertex outgoing edge: " << BOLD_WHITE << firstVertex << BOLD_YELLOW << " -> " << BOLD_WHITE << vertex << RESET << "\n");
            // }
            
            counter = 1;
            
            prevVertex =  tempBBName  = bbName;

            const auto &libCalls = bbEntry.second;
            std::string vertexName;
            for (const auto &libCall : libCalls) {
                vertexName = bbName + ((libCall.find("user:") == 0) ? "-user_" : "-libc_") + std::to_string(counter++);
                bbExpandedGraph.add_vertex(vertexName);

                bbExpandedGraph.add_edge(prevVertex, vertexName, libCall);
                // DEBUG_PRINT(BOLD_YELLOW << "$$ Adding edge: " << BOLD_WHITE << prevVertex << BOLD_YELLOW << " -> " << BOLD_WHITE << vertexName << BOLD_YELLOW << " (" << BOLD_WHITE << libCall << BOLD_YELLOW << ")" << RESET << "\n");
                prevVertex = vertexName;
                hadLibcCalls = true;
            }
            if (funcMeta.exitNode == bbName) {
                funcMeta.exitNode = vertexName;
            }
            if (!neighbors.empty()) {
                // DEBUG_PRINT(BOLD_YELLOW << "Adding edge: " << BOLD_WHITE << firstVertex << BOLD_YELLOW << " -> " << BOLD_WHITE << funcMeta.exitNode << RESET << "\n");
                for (const auto &vertex : neighbors) {
                    bbExpandedGraph.remove_edge(firstVertex, vertex);
                    // DEBUG_PRINT(BOLD_YELLOW << "@@ Removing edge: " << BOLD_WHITE << firstVertex << BOLD_YELLOW << " -> " << BOLD_WHITE << vertex << RESET << "\n");
                    bbExpandedGraph.add_edge(prevVertex, vertex, "control");
                    // DEBUG_PRINT(BOLD_YELLOW << "@@ Adding edge: " << BOLD_WHITE << prevVertex << BOLD_YELLOW << " -> " << BOLD_WHITE << vertex << RESET << "\n");
                }
                neighbors.clear();
            }
            // if (counter > 1) {
            //     // DEBUG_PRINT(BOLD_YELLOW << "Removing edge: " << BOLD_WHITE << tempBBName << BOLD_YELLOW << " -> " << BOLD_WHITE << funcMeta.exitNode << RESET << "\n");
            //     bbExpandedGraph.remove_edge(tempBBName, funcMeta.exitNode);
            //     // DEBUG_PRINT(BOLD_YELLOW << "Adding edge: " << BOLD_WHITE << prevVertex << BOLD_YELLOW << " -> " << BOLD_WHITE << funcMeta.exitNode << RESET << "\n");
            //     bbExpandedGraph.add_edge(prevVertex, funcMeta.exitNode, "control");
            // }
        }

        // std::string outputFilename = OuputFilepathPrefix +'/'+ OuputFilenamePrefix + funcName + "-expanded.dot";
        // funcMeta.bbExpandedGraph.dump_todot(outputFilename);

        // DEBUG_PRINT(BOLD_GREEN << "Output filename: " << BOLD_WHITE << outputFilename << RESET << "\n");
        // DEBUG_PRINT(BOLD_GREEN << "\tEntry Node: " << BOLD_WHITE << funcMeta.entryNode << RESET << "\n");
        // DEBUG_PRINT(BOLD_GREEN << "\tExit Node: " << BOLD_WHITE << funcMeta.exitNode << RESET << "\n");        
    }
}

//------------------------------------------------------------------------------
// Convert expanded basic block graph to libc call graph
//------------------------------------------------------------------------------

/**
 * @brief Convert the basic block graph to a libc call graph
 */
void ConvertBBGraphToLibcCallGraph(){
    for (auto &entry : funcBBToMetaMap) {
        auto &funcMeta = entry.second;
        const auto &funcName = entry.first;
        auto &bbExpandedGraph = funcMeta.bbExpandedGraph;
        auto &libcCallGraph = funcMeta.libcCallGraph;
        // DEBUG_PRINT(BOLD_RED << "===================================================== " RESET << "\n");
        // DEBUG_PRINT(BOLD_GREEN << "Function: " << BOLD_WHITE << funcName << RESET << "\n");
        // DEBUG_PRINT(BOLD_RED << "===================================================== " RESET << "\n");

        libcCallGraph = bbExpandedGraph;

        bool noMergeFound = false;
        int count = 0;

        while (!noMergeFound) {
            // DEBUG_PRINT(BOLD_YELLOW << "__________________________________________________\n");
            // DEBUG_PRINT(BOLD_YELLOW << "Iteration: " << BOLD_WHITE << count++ << RESET << "\n");
            noMergeFound = true;
            for (const auto &vertex : libcCallGraph.get_vertices()) {
                const std::vector<std::string> neighbors = libcCallGraph.get_control_edge_neighbors(vertex);
                // DEBUG_PRINT(BOLD_YELLOW << "Checking neighbors for : "<< BOLD_WHITE << vertex << " (" << neighbors.size() << ")" << RESET);
                // for (const auto &neighbor : neighbors) {
                //     DEBUG_PRINT(BOLD_YELLOW << " -> " << BOLD_WHITE << neighbor << RESET);
                // }
                // DEBUG_PRINT("\n");

                if (neighbors.size() >= 1) {
                    for (const auto &neighbor : neighbors) {

                        // DEBUG_PRINT(BOLD_YELLOW << "Merging: " << BOLD_WHITE << vertex << BOLD_YELLOW << " -> " << BOLD_WHITE << neighbor << RESET << "\n");
                        libcCallGraph.combine_vertex(vertex, neighbor);
                        if (funcMeta.exitNode == neighbor) {
                            funcMeta.exitNode = vertex;
                        }
                    }
                    noMergeFound = false;
                }
            }
        }

        // std::string outputFilename = OuputFilepathPrefix +'/'+ OuputFilenamePrefix + funcName + "-libc.dot";
        // funcMeta.libcCallGraph.dump_todot(outputFilename);

        // DEBUG_PRINT(BOLD_GREEN << "Output filename: " << BOLD_WHITE << outputFilename << RESET << "\n");
        // DEBUG_PRINT(BOLD_GREEN << "\tEntry Node: " << BOLD_WHITE << funcMeta.entryNode << RESET << "\n");
        // DEBUG_PRINT(BOLD_GREEN << "\tExit Node: " << BOLD_WHITE << funcMeta.exitNode << RESET << "\n");
    }
}

//------------------------------------------------------------------------------
// Combine the libc call graphs of each functions to create the final graph
//------------------------------------------------------------------------------

void CombineLibcgGraph (){
    finalGraph = funcBBToMetaMap["main"].libcCallGraph;
    finalGraphEntryNode = funcBBToMetaMap["main"].entryNode;
    finalGraphExitNode = funcBBToMetaMap["main"].exitNode;

    // DEBUG_PRINT(BOLD_YELLOW << "Main function: " << BOLD_WHITE << "main" << RESET << "\n");
    for(auto &entry : finalGraph.get_vertices()){
        // DEBUG_PRINT(BOLD_YELLOW << "Vertex: " << BOLD_WHITE << entry << RESET << "\n");
        for(auto &edge : finalGraph.get_outgoing_edges(entry)){
            // DEBUG_PRINT(BOLD_YELLOW << "    Edge: " << BOLD_WHITE << edge << RESET << "\n");
            
            if (edge.find("user:") == 0) {
                std::string functionCall = edge.substr(5);
                // DEBUG_PRINT(BOLD_YELLOW << "        Function call: " << BOLD_WHITE << functionCall << RESET << "\n");
                LibcCallgraph funcGraph = funcBBToMetaMap[functionCall].libcCallGraph;
                std::string func_entry = funcBBToMetaMap[functionCall].entryNode;
                std::string func_exit = funcBBToMetaMap[functionCall].exitNode;

                // DEBUG_PRINT(BOLD_YELLOW << "        Entry: " << BOLD_WHITE << func_entry << RESET << "\n");
                // DEBUG_PRINT(BOLD_YELLOW << "        Exit: " << BOLD_WHITE << func_exit << RESET << "\n");
                finalGraph.insert_graph(funcGraph, func_entry, func_exit);   
                finalGraph.add_edge(entry, func_entry, "control");
                finalGraph.add_edge(func_exit, finalGraph.get_neighbors(entry).front(), "control");
            }
        }
    }

    bool noMergeFound = false;
    int count = 0;

    while (!noMergeFound) {
        // DEBUG_PRINT(BOLD_YELLOW << "__________________________________________________\n");
        // DEBUG_PRINT(BOLD_YELLOW << "Iteration: " << BOLD_WHITE << count++ << RESET << "\n");
        noMergeFound = true;
        for (const auto &vertex : finalGraph.get_vertices()) {
            const std::vector<std::string> neighbors = finalGraph.get_control_edge_neighbors(vertex);
            // DEBUG_PRINT(BOLD_YELLOW << "Checking neighbors for : "<< BOLD_WHITE << vertex << " (" << neighbors.size() << ")" << RESET);
            // for (const auto &neighbor : neighbors) {
            //     DEBUG_PRINT(BOLD_YELLOW << " -> " << BOLD_WHITE << neighbor << RESET);
            // }
            // DEBUG_PRINT("\n");

            if (neighbors.size() >= 1) {
                for (const auto &neighbor : neighbors) {

                    // DEBUG_PRINT(BOLD_YELLOW << "Merging: " << BOLD_WHITE << vertex << BOLD_YELLOW << " -> " << BOLD_WHITE << neighbor << RESET << "\n");
                    finalGraph.combine_vertex(vertex, neighbor);
                    if (finalGraphExitNode == neighbor) {
                        finalGraphExitNode = vertex;
                    }
                }
                noMergeFound = false;
            }

            const std::vector<std::string> neighbors_user = finalGraph.get_user_edge_neighbors(vertex);
            // DEBUG_PRINT(BOLD_YELLOW << "Checking neighbors for : "<< BOLD_WHITE << vertex << " (" << neighbors.size() << ")" << RESET);
            // for (const auto &neighbor : neighbors) {
            //     DEBUG_PRINT(BOLD_YELLOW << " -> " << BOLD_WHITE << neighbor << RESET);
            // }
            // DEBUG_PRINT("\n");

            if (neighbors_user.size() >= 1) {
                for (const auto &neighbor : neighbors_user) {

                    // DEBUG_PRINT(BOLD_YELLOW << "Merging: " << BOLD_WHITE << vertex << BOLD_YELLOW << " -> " << BOLD_WHITE << neighbor << RESET << "\n");
                    finalGraph.combine_vertex(vertex, neighbor);
                    if (finalGraphExitNode == neighbor) {
                        finalGraphExitNode = vertex;
                    }
                }
                noMergeFound = false;
            }

        }
    }


    std::string outputFilename = OuputFilepathPrefix +'/'+ OuputFilenamePrefix + "final.dot";
    finalGraph.dump_todot(outputFilename, finalGraphEntryNode, finalGraphExitNode);
    DEBUG_PRINT(BOLD_GREEN << "Output filename: " << BOLD_WHITE << outputFilename << RESET << "\n");
    DEBUG_PRINT(BOLD_GREEN << "\tEntry Node: " << BOLD_WHITE << finalGraphEntryNode << RESET << "\n");
    DEBUG_PRINT(BOLD_GREEN << "\tExit Node: " << BOLD_WHITE << finalGraphExitNode << RESET << "\n");
}


//------------------------------------------------------------------------------
// Generate the in-memory graph to be embedded in to the program
//------------------------------------------------------------------------------
#include "memgraph.h"
void LibcSandboxing::GenerateInMemoryGraph(llvm::Module &M){
    int numOutEdges = 0;
    const int MAX_NEIGHBORS = 1000;
    const int MODULUS = 1000;
    unsigned long neighborList [MAX_NEIGHBORS] , edgeList[MAX_NEIGHBORS];
    initialize_graph(NULL, 0);

    for (const auto &vertex : finalGraph.get_vertices()) {
        // Calculate the hash of the vertex - to have unique ID for the node
        std::size_t strId = std::hash<std::string>{}(vertex)  % MODULUS;

        for (const auto &vertex : finalGraph.get_vertices()) {
            for (const auto &edge : finalGraph.get_outgoing_edges(vertex)) {
                std::string edgeStr = (edge.find("libc:") == 0) ? edge.substr(5) : edge;
                int libcId = fileToMapReader.getValueFromMap(edgeStr);
                edgeList[numOutEdges] = libcId;
            }

            for (const auto &edge : finalGraph.get_neighbors(vertex)) {
                neighborList[numOutEdges] = std::hash<std::string>{}(edge) % MODULUS;
            }
            numOutEdges++;
            assert (numOutEdges < MAX_NEIGHBORS);
        }
        alloc_node(strId, numOutEdges, edgeList, neighborList);
    }
    
    finalize_graph();
    void * graph = get_graph();
    SectionAddressHandler(M, (unsigned char*)graph, (1024 * 1024));
    destroy_graph();    
}

//------------------------------------------------------------------------------
// New PM interface
//------------------------------------------------------------------------------
bool LibcSandboxing::runOnModule(Module &M, ModuleAnalysisManager &MAM, FunctionAnalysisManager &FAM) {
    bool InsertedAtLeastOnePrintf = false;
    std::map<std::string, std::vector<std::string>> funcToLibcMap;
    
    setupDummySyscall(M);
    

    for (auto &F : M) {
        struct funcBBGraphMeta funcMeta;
        
        if (F.isDeclaration()) continue;            // Skip external functions
        std::string funcName = F.getName().str();
        if (funcName.find("llvm.") == 0) continue; // Skip internal LLVM functions
        if (funcName.find("syscall") == 0) continue; // Skip the syscall wrapper function used for injection

        // DEBUG_PRINT(GREEN<<"\n===== Function: " << WHITE << funcName << GREEN << " =====\n"<<RESET);
        LoopInfo &LI = FAM.getResult<LoopAnalysis>(F);
        funcMeta.funcName = funcName;
        ///// Name the basic blocks
        nameBasicBlocks(F);        

        ///// Generate the call graph - vertices/basicblocks
        for (BasicBlock &BB : F) {
            // DEBUG_PRINT_BB(BB);
            auto *TI = BB.getTerminator();
            if (BB.hasNPredecessors(0)) {
                funcMeta.entryNode = BB.getName().str();
                funcMeta.bbGraph.add_vertex(BB.getName().str(), (fileToMapReader.getLibraryCalls(BB).empty()) ? false : true);
                // DEBUG_PRINT("ENTRY\n");
            } 
                
            if (isa<ReturnInst>(TI)) {
                funcMeta.exitNode = BB.getName().str();
                funcMeta.bbGraph.add_vertex(BB.getName().str(),(fileToMapReader.getLibraryCalls(BB).empty()) ? false : true);
                // DEBUG_PRINT("EXIT\n");
                continue;
            }

            funcMeta.bbGraph.add_vertex(BB.getName().str(),
                                    (fileToMapReader.getLibraryCalls(BB).empty()) ? false : true);
            // DEBUG_PRINT("INTERNAL\n");
        }

        ///// Generate the call graph - populate edges
        for (BasicBlock &BB : F) {
            for (BasicBlock *Succ : successors(&BB)) {
                funcMeta.bbGraph.add_edge(BB.getName().str(), Succ->getName().str(), "control");
            }
        }

        ///// Generate the libc call list for each BB
        for (BasicBlock &BB : F) {
            std::vector<std::string> libCalls = fileToMapReader.getLibraryCalls(BB);
            if (!libCalls.empty()) {
                funcMeta.bbToLibcMap[BB.getName().str()] = libCalls;
            }
        }
        funcBBToMetaMap[funcName] = funcMeta;
        
        // std::string outputFilename = OuputFilepathPrefix +'/'+ OuputFilenamePrefix + funcName + ".dot";
        // funcMeta.bbGraph.dump_todot(outputFilename);

        // DEBUG_PRINT(BOLD_GREEN << "Output filename: " << BOLD_WHITE << outputFilename << RESET << "\n");
       
        
        ///// Inject the dummy syscall
        for (BasicBlock &BB : F) {
            for (Instruction &I : BB) {
                if (CallInst *CI = dyn_cast<CallInst>(&I)) {
                    Function *Callee = CI->getCalledFunction();
                    if (Callee) {
                        std::string funcName = Callee->getName().str();
                        if (fileToMapReader.isStringInMap(funcName)) {
                            int syscallNum = fileToMapReader.getValueFromMap(funcName);
                            // DEBUG_PRINT(BOLD_YELLOW << "Found libc call: " << BOLD_MAGENTA << funcName << RESET << " - syscall number: " << syscallNum << "\n");
                            injectDummySyscall(I, syscallNum);
                            InsertedAtLeastOnePrintf = true;
                        }
                    }
                }
            }
        }
    
  }
////////////////////////////////////////////////////////////
//    // Dump the function to libc call map
//     for (const auto &entry : funcToLibcMap) {
//         DEBUG_PRINT(BOLD_GREEN << "-----------------Function: " << BOLD_WHITE << entry.first << RESET << "\n");
//         for (const auto &libCall : entry.second) {
//             DEBUG_PRINT(BOLD_YELLOW << "  Libc Call: " << BOLD_MAGENTA << libCall << RESET << "\n");
//         }
//     }
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
//// Dump the function to meta map
// for (const auto &entry : funcBBToMetaMap) {
//     const auto &funcMeta = entry.second;
//     DEBUG_PRINT(BOLD_GREEN << "Function: " << BOLD_WHITE << funcMeta.funcName << RESET << "\n");
//     DEBUG_PRINT(BOLD_GREEN << "  Entry Node: " << BOLD_WHITE << funcMeta.entryNode << RESET << "\n");
//     DEBUG_PRINT(BOLD_GREEN << "  Exit Node: " << BOLD_WHITE << funcMeta.exitNode << RESET << "\n");
//     DEBUG_PRINT(BOLD_GREEN << "  Basic Blocks to Func Calls Map:" << RESET << "\n");
//     for (const auto &bbEntry : funcMeta.bbToLibcMap) {
//         DEBUG_PRINT(BOLD_YELLOW << "    Basic Block: " << BOLD_WHITE << bbEntry.first << RESET << "\n");
//         for (const auto &libCall : bbEntry.second) {
//             DEBUG_PRINT(BOLD_MAGENTA << "      Func Call: " << BOLD_WHITE << libCall << RESET << "\n");
//         }
//     }
// }
////////////////////////////////////////////////////////////
    ExpandBBGraph();
    ConvertBBGraphToLibcCallGraph();
    CombineLibcgGraph ();
    GenerateInMemoryGraph(M);
    MemoryCleanupHandler(M);
    return InsertedAtLeastOnePrintf;
}

PreservedAnalyses LibcSandboxing::run(llvm::Module &M,
                                       llvm::ModuleAnalysisManager &AM) {
    FunctionAnalysisManager &FAM = AM.getResult<FunctionAnalysisManagerModuleProxy>(M).getManager();
    fileToMapReader.readFileToMap(InputLibFuncsPath);
    bool Changed =  runOnModule(M, AM, FAM);

    return (Changed ? llvm::PreservedAnalyses::none()
                  : llvm::PreservedAnalyses::all());
}


//-----------------------------------------------------------------------------
// New PM Registration
//-----------------------------------------------------------------------------
llvm::PassPluginLibraryInfo getInjectFuncCallPluginInfo() {
  return {LLVM_PLUGIN_API_VERSION, "libc-sandboxing", LLVM_VERSION_STRING,
          [](PassBuilder &PB) {
            PB.registerPipelineParsingCallback(
                [](StringRef Name, ModulePassManager &MPM,
                   ArrayRef<PassBuilder::PipelineElement>) {
                  if (Name == "libc-sandboxing") {
                    MPM.addPass(LibcSandboxing());
                    return true;
                  }
                  return false;
                });
          }};
}

extern "C" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo
llvmGetPassPluginInfo() {
  return getInjectFuncCallPluginInfo();
}
